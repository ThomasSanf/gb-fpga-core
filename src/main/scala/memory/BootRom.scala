package memory

import chisel3._
import chisel3.util._

class BootRomIO extends Bundle {
  val address = Input(UInt(16.W))
  val dataOut = Output(UInt(8.W))
  val valid   = Output(Bool())
  val enabled = Input(Bool())  // Boot ROM disable register (0xFF50)
}

/**
 * Game Boy Boot ROM
 *
 * The boot ROM displays the Nintendo logo and plays the boot sound.
 * It occupies addresses 0x0000-0x00FF when enabled.
 * Games write 0x01 to 0xFF50 to disable it and start the actual game.
 */
class BootRom extends Module {
  val io = IO(new BootRomIO)

  // Boot ROM data (256 bytes)
  // This is the DMG (original Game Boy) boot ROM
  val bootRomData = VecInit(
    0x31.U, 0xFE.U, 0xFF.U, 0xAF.U, 0x21.U, 0xFF.U, 0x9F.U, 0x32.U,
    0xCB.U, 0x7C.U, 0x20.U, 0xFB.U, 0x21.U, 0x26.U, 0xFF.U, 0x0E.U,
    0x11.U, 0x3E.U, 0x80.U, 0x32.U, 0xE2.U, 0x0C.U, 0x3E.U, 0xF3.U,
    0xE2.U, 0x32.U, 0x3E.U, 0x77.U, 0x77.U, 0x3E.U, 0xFC.U, 0xE0.U,
    0x47.U, 0x11.U, 0x04.U, 0x01.U, 0x21.U, 0x10.U, 0x80.U, 0x1A.U,
    0xCD.U, 0x95.U, 0x00.U, 0xCD.U, 0x96.U, 0x00.U, 0x13.U, 0x7B.U,
    0xFE.U, 0x34.U, 0x20.U, 0xF3.U, 0x11.U, 0xD8.U, 0x00.U, 0x06.U,
    0x08.U, 0x1A.U, 0x13.U, 0x22.U, 0x23.U, 0x05.U, 0x20.U, 0xF9.U,
    0x3E.U, 0x19.U, 0xEA.U, 0x10.U, 0x99.U, 0x21.U, 0x2F.U, 0x99.U,
    0x0E.U, 0x0C.U, 0x3D.U, 0x28.U, 0x08.U, 0x32.U, 0x0D.U, 0x20.U,
    0xF9.U, 0x2E.U, 0x0F.U, 0x18.U, 0xF3.U, 0x67.U, 0x3E.U, 0x64.U,
    0x57.U, 0xE0.U, 0x42.U, 0x3E.U, 0x91.U, 0xE0.U, 0x40.U, 0x04.U,
    0x1E.U, 0x02.U, 0x0E.U, 0x0C.U, 0xF0.U, 0x44.U, 0xFE.U, 0x90.U,
    0x20.U, 0xFA.U, 0x0D.U, 0x20.U, 0xF7.U, 0x1D.U, 0x20.U, 0xF2.U,
    0x0E.U, 0x13.U, 0x24.U, 0x7C.U, 0x1E.U, 0x83.U, 0xFE.U, 0x62.U,
    0x28.U, 0x06.U, 0x1E.U, 0xC1.U, 0xFE.U, 0x64.U, 0x20.U, 0x06.U,
    0x7B.U, 0xE2.U, 0x0C.U, 0x3E.U, 0x87.U, 0xE2.U, 0xF0.U, 0x42.U,
    0x90.U, 0xE0.U, 0x42.U, 0x15.U, 0x20.U, 0xD2.U, 0x05.U, 0x20.U,
    0x4F.U, 0x16.U, 0x20.U, 0x18.U, 0xCB.U, 0x4F.U, 0x06.U, 0x04.U,
    0xC5.U, 0xCB.U, 0x11.U, 0x17.U, 0xC1.U, 0xCB.U, 0x11.U, 0x17.U,
    0x05.U, 0x20.U, 0xF5.U, 0x22.U, 0x23.U, 0x22.U, 0x23.U, 0xC9.U,
    0xCE.U, 0xED.U, 0x66.U, 0x66.U, 0xCC.U, 0x0D.U, 0x00.U, 0x0B.U,
    0x03.U, 0x73.U, 0x00.U, 0x83.U, 0x00.U, 0x0C.U, 0x00.U, 0x0D.U,
    0x00.U, 0x08.U, 0x11.U, 0x1F.U, 0x88.U, 0x89.U, 0x00.U, 0x0E.U,
    0xDC.U, 0xCC.U, 0x6E.U, 0xE6.U, 0xDD.U, 0xDD.U, 0xD9.U, 0x99.U,
    0xBB.U, 0xBB.U, 0x67.U, 0x63.U, 0x6E.U, 0x0E.U, 0xEC.U, 0xCC.U,
    0xDD.U, 0xDC.U, 0x99.U, 0x9F.U, 0xBB.U, 0xB9.U, 0x33.U, 0x3E.U,
    0x3C.U, 0x42.U, 0xB9.U, 0xA5.U, 0xB9.U, 0xA5.U, 0x42.U, 0x3C.U,
    0x21.U, 0x04.U, 0x01.U, 0x11.U, 0xA8.U, 0x00.U, 0x1A.U, 0x13.U,
    0xBE.U, 0x20.U, 0xFE.U, 0x23.U, 0x7D.U, 0xFE.U, 0x34.U, 0x20.U,
    0xF5.U, 0x06.U, 0x19.U, 0x78.U, 0x86.U, 0x23.U, 0x05.U, 0x20.U,
    0xFB.U, 0x86.U, 0x20.U, 0xFE.U, 0x3E.U, 0x01.U, 0xE0.U, 0x50.U
  )

  // Check if boot ROM should respond
  val inBootRange = io.address < 0x100.U
  io.valid := io.enabled && inBootRange

  // Output data
  when(io.valid) {
    io.dataOut := bootRomData(io.address(7, 0))
  }.otherwise {
    io.dataOut := 0.U
  }
}